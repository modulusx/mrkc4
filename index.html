<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>Connect 4</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.2/normalize.min.css">
	<style type="text/css" media="all">
	#main {
		background-color: blue;
		width: 350px;
		overflow: hidden;
	}
	.item {
		border-radius: 55px;
		background-color: #fff;
		width: 40px;
		height: 40px;
		float: left;
		border: 5px solid blue;
	}
	.item.active {
		background-color: #00ff00;
	}
	.item.red {
		background-color: #ff0000;
	}
	.item.yellow {
		background-color: yellow;
	}
	.row-0 {
		cursor: pointer;
	}
	</style>
</head>
<body>
	<div id="main">
	</div>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.2/underscore-min.js"></script>
	<script type="text/javascript" charset="utf-8">
		/**
		 *   Description
		 *
		 * you are to finalize the current code, the end goal is a fully functional connect-four game
		 * while documenting each of your steps commiting this to an either public or private git repo
		 * (which you need to make available to the reviewer), the game should be a user vs user game on which
		 * you click a column and drops a coin, first to click is yellow
		 *
		 * (Reference: http://en.wikipedia.org/wiki/Connect_Four_
		 **/
		/**
		 *   Rules
		 *
		 * - assume modern browsers
		 * - only use available tools already in this file (normalize.css, jquery, underscore)
		 * - you can optimize or replace existing code
		 * - commit as often as you would normally
		 **/

		// Dynamically size the table.
		var tableWidth = 7;
		var tableHeight = 6;
		var tableSize = [tableWidth, tableHeight];

		// Number of consecutive pieces required to win
		var piecesToWin = 4;

		// Maintain state of the gameboard in a 2D array
		var tableState = _.range(tableWidth).map(function () {
			return _.range(tableHeight).map(function () {
				return 0;
			});
		});

		// Initialize an array containing the current index for each unfilled row
		var activeRow = _.range(tableWidth).map(function() { return tableHeight-1; });

		// Keep track of the total number of moves
		var totalMoves = 0;
		var lastMovedBy = false;
		var currentPlayer = false;

		var dropCircle = function(colIndex) {
			// Keep track of the total number of moves
			totalMoves++;
			lastMovedBy = currentPlayer;
			currentPlayer = !currentPlayer;

			// Position should be the first empty spot starting at the table going up
			var pos = activeRow[colIndex]--;

			$('.item.col-' + colIndex + '.row-' + pos).addClass((currentPlayer ? 'yellow' : 'red'));
			tableState[colIndex][pos] = currentPlayer ? 1 : 2;
			tryToGameOver(colIndex, pos);

			// Unbind the click listener on a full column
			if (pos === 0) {
				$('.item.col-' + colIndex + '.row-' + pos).unbind('click');
			}
		};
		var tryToGameOver = function(col, row) {
			// Check to see if the current player just won the game
			if (1 + piecesInRow(col,row,0) >= piecesToWin) {
				alert('Game Over - '+((currentPlayer ? 'Yellow' : 'Red')+' wins the game!'));
			}
			// End the game on a Tie if no one wins and board is full
			else if (totalMoves === (tableHeight * tableWidth)) {
				alert('Game Over - Tie Game!');
			}
		};
		// Recursive function to return value of the row with the most consecutive pieces for the current player
		var piecesInRow = function(col,row,dir) {
			// End conditions - outside the bounds of the table, or non-player value in table
			if ((col < 0 || tableWidth <= col) || (row < 0 || tableHeight <= row) ||
				 (tableState[col][row] != (currentPlayer ? 1 : 2))) {
				return 0;
			}
			switch(dir) {
				// First run - create and run each required recursive function
				case 0:
					return _.max([piecesInRow(col,row+1,4),// Search [north] and south
					piecesInRow(col+1,row-1,1)+piecesInRow(col-1,row+1,5), // Search NE and SW
					piecesInRow(col+1,row,2)+piecesInRow(col-1,row,6), // Search east and west
					piecesInRow(col+1,row+1,3)+piecesInRow(col-1,row-1,7) // Search SE and NW
					]);

					break;
				case 1:
					return 1+piecesInRow(col+1,row-1,1);
					break;
				case 2:
					return 1+piecesInRow(col+1,row,2);
					break;
				case 3:
					return 1+piecesInRow(col+1,row+1,3);
					break;
				case 4:
					return 1+piecesInRow(col,row+1,4);
					break;
				case 5:
					return 1+piecesInRow(col-1,row+1,5);
					break;
				case 6:
					return 1+piecesInRow(col-1,row,6);
					break;
				case 7:
					return 1+piecesInRow(col-1,row-1,7);
					break;
			}
		};
		var gameOver = function() {
			var winner = (lastMovedBy) ? 'yellow' : 'red';
			console.log('Winner: ' + winner);
		};
		var createConnectCircle = function(colIndex, rowIndex) {
			var item = $('<div>').addClass('item').addClass('col-' + colIndex).addClass('row-' + rowIndex);
			if (rowIndex === 0) {
				item.bind('click', clickHandler);
			}
			return item;
		};
		var clickHandler = function(event) {
			event.preventDefault();
			var colIndex = $(this).prop('class').split(' ')[1].split('-').reverse()[0];
			colIndex = parseInt(colIndex, 10);
			dropCircle(colIndex);
		};
		_(tableSize[1]).times(function(rowIndex) {
			_(tableSize[0]).times(function(colIndex) {
				$('#main').append(createConnectCircle(colIndex, rowIndex));
			});
		});
	</script>
	</body>
</html>
